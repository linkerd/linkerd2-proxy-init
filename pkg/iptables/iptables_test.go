package iptables

import (
	"os/exec"
	"reflect"
	"testing"
)

func TestMakeMultiportDestinations(t *testing.T) {
	assertEqual(t, makeMultiportDestinations([]string{}), [][]string{})
	assertEqual(t, makeMultiportDestinations([]string{"22", "25-27", "33"}), [][]string{{"22", "25:27", "33"}})
	assertEqual(t, makeMultiportDestinations([]string{"22-22", "25-27", "33"}), [][]string{{"22", "25:27", "33"}})
	assertEqual(t, makeMultiportDestinations([]string{"22", "25-27", "not-a-number", "33"}), [][]string{{"22", "25:27", "33"}})
	assertEqual(t, makeMultiportDestinations([]string{"22", "25-27", "notanumber", "33"}), [][]string{{"22", "25:27", "33"}})
}

func TestMakeMultiportDestinations_Split(t *testing.T) {
	assertEqual(t,
		makeMultiportDestinations([]string{"22-23", "25-27", "33-34", "35-35", "37-38", "50-54", "56-57", "60-63"}),
		[][]string{{"22:23", "25:27", "33:34", "35", "37:38", "50:54", "56:57", "60:63"}})
	assertEqual(t,
		makeMultiportDestinations([]string{"22-23", "25-27", "33-34", "35-35", "37-38", "50-54", "56", "58", "60", "63", "70-72"}),
		[][]string{{"22:23", "25:27", "33:34", "35", "37:38", "50:54", "56", "58", "60", "63"}, {"70:72"}})
}

var existingRules = []byte(`# iptables-save
# Generated by iptables-save v1.6.1 on Fri Jan  6 23:00:00 2023
*nat
:PREROUTING ACCEPT [0:0]
:INPUT ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:PROXY_INIT_OUTPUT - [0:0]
:PROXY_INIT_REDIRECT - [0:0]
-A PREROUTING -m comment --comment "proxy-init/install-proxy-init-prerouting" -j PROXY_INIT_REDIRECT
-A OUTPUT -m comment --comment "proxy-init/install-proxy-init-output" -j PROXY_INIT_OUTPUT
-A PROXY_INIT_OUTPUT -o lo -m comment --comment "proxy-init/ignore-loopback" -j RETURN
-A PROXY_INIT_OUTPUT -p tcp -m comment --comment "proxy-init/redirect-all-outgoing-to-proxy-port" -j REDIRECT --to-ports 1234
-A PROXY_INIT_REDIRECT -p tcp -m multiport --dports 1234 -m comment --comment "proxy-init/ignore-port-1234" -j RETURN
COMMIT
# Completed on Fri Jan  6 23:00:00 2023
`)

func TestAddIncomingTrafficRules(t *testing.T) {
	for _, tt := range []struct {
		name          string
		existingRules []byte
		wantCommands  []*exec.Cmd
	}{
		{
			name: "no existing rules, create new chain and PREROUTING rule",
			wantCommands: []*exec.Cmd{
				exec.Command("<iptables>", "-t", "nat", "-N", "PROXY_INIT_REDIRECT"),
				exec.Command("<iptables>", "-t", "nat", "-A", "PROXY_INIT_REDIRECT", "-p", "tcp", "--match", "multiport", "--dports", "1234", "-j", "RETURN", "-m", "comment", "--comment", "proxy-init/ignore-port-1234"),
				exec.Command("<iptables>", "-t", "nat", "-A", "PREROUTING", "-j", "PROXY_INIT_REDIRECT", "-m", "comment", "--comment", "proxy-init/install-proxy-init-prerouting"),
			},
		},
		{
			name:          "existing rules, flush existing chain and reuse PREROUTING rule",
			existingRules: existingRules,
			wantCommands: []*exec.Cmd{
				exec.Command("<iptables>", "-t", "nat", "-F", "PROXY_INIT_REDIRECT"),
				exec.Command("<iptables>", "-t", "nat", "-A", "PROXY_INIT_REDIRECT", "-p", "tcp", "--match", "multiport", "--dports", "1234", "-j", "RETURN", "-m", "comment", "--comment", "proxy-init/ignore-port-1234"),
			},
		},
	} {
		t.Run(tt.name, func(t *testing.T) {
			fc := &FirewallConfiguration{
				BinPath:              "<iptables>",
				InboundPortsToIgnore: []string{"1234"},
			}
			cmds := fc.addIncomingTrafficRules(tt.existingRules, nil)
			assertEqual(t, cmds, tt.wantCommands)
		})
	}
}

func TestAddOutgoingTrafficRules(t *testing.T) {
	for _, tt := range []struct {
		name          string
		existingRules []byte
		wantCommands  []*exec.Cmd
	}{
		{
			name: "no existing rules, create new chain and OUTPUT rule",
			wantCommands: []*exec.Cmd{
				exec.Command("<iptables>", "-t", "nat", "-N", "PROXY_INIT_OUTPUT"),
				exec.Command("<iptables>", "-t", "nat", "-A", "PROXY_INIT_OUTPUT", "-o", "lo", "-j", "RETURN", "-m", "comment", "--comment", "proxy-init/ignore-loopback"),
				exec.Command("<iptables>", "-t", "nat", "-A", "PROXY_INIT_OUTPUT", "-p", "tcp", "-j", "REDIRECT", "--to-port", "1234", "-m", "comment", "--comment", "proxy-init/redirect-all-outgoing-to-proxy-port"),
				exec.Command("<iptables>", "-t", "nat", "-A", "OUTPUT", "-j", "PROXY_INIT_OUTPUT", "-m", "comment", "--comment", "proxy-init/install-proxy-init-output"),
			},
		},
		{
			name:          "existing rules, flush existing chain and reuse OUTPUT rule",
			existingRules: existingRules,
			wantCommands: []*exec.Cmd{
				exec.Command("<iptables>", "-t", "nat", "-F", "PROXY_INIT_OUTPUT"),
				exec.Command("<iptables>", "-t", "nat", "-A", "PROXY_INIT_OUTPUT", "-o", "lo", "-j", "RETURN", "-m", "comment", "--comment", "proxy-init/ignore-loopback"),
				exec.Command("<iptables>", "-t", "nat", "-A", "PROXY_INIT_OUTPUT", "-p", "tcp", "-j", "REDIRECT", "--to-port", "1234", "-m", "comment", "--comment", "proxy-init/redirect-all-outgoing-to-proxy-port"),
			},
		},
	} {
		t.Run(tt.name, func(t *testing.T) {
			fc := &FirewallConfiguration{
				BinPath:           "<iptables>",
				ProxyOutgoingPort: 1234,
			}
			cmds := fc.addOutgoingTrafficRules(tt.existingRules, nil)
			assertEqual(t, cmds, tt.wantCommands)
		})
	}

}

func TestCleanupFirewallConfig(t *testing.T) {
	wantCommands := []*exec.Cmd{
		exec.Command("<iptables>", "-t", "nat", "-D", "PREROUTING", "-j", "PROXY_INIT_REDIRECT", "-m", "comment", "--comment", "proxy-init/install-proxy-init-prerouting"),
		exec.Command("<iptables>", "-t", "nat", "-D", "OUTPUT", "-j", "PROXY_INIT_OUTPUT", "-m", "comment", "--comment", "proxy-init/install-proxy-init-output"),
		exec.Command("<iptables>", "-t", "nat", "-F", "PROXY_INIT_OUTPUT"),
		exec.Command("<iptables>", "-t", "nat", "-F", "PROXY_INIT_REDIRECT"),
		exec.Command("<iptables>", "-t", "nat", "-X", "PROXY_INIT_OUTPUT"),
		exec.Command("<iptables>", "-t", "nat", "-X", "PROXY_INIT_REDIRECT"),
	}

	fc := &FirewallConfiguration{
		BinPath:              "<iptables>",
		InboundPortsToIgnore: []string{"1234"},
	}
	cmds := fc.cleanupRules(nil)
	assertEqual(t, cmds, wantCommands)

}

func assertEqual(t *testing.T, check, expected interface{}) {
	if !reflect.DeepEqual(check, expected) {
		t.Fatalf("mismatch: got \"%s\" expected \"%s\"", check, expected)
	}
}
